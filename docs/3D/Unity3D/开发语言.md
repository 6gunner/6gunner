
c#语言开发 => roslyn引擎实时编译成`IL指令`（dlll文件） => **mono-runtime**编译成cpu指令集

**mono-runtime**: 跨平台的解决方案

IL指令=>**IL2CPP** 转化成C++ => 打包成exe文件、
**IL2CPP**:  更好的解决跨平台build问题


## 编程思想

**游戏对象**：面向对象思维，一切物体都是对象；

**游戏组件**：对象里可以关联n个组件，一切逻辑都是用组件的形式实现的。包括编程脚本，也是一个组件，（自定义组件就是自己实现代码）

**组件种类：** `Transform`, `Mesh Render`,  `Mesh Filter`


## 继承关系

对象 => Component

`Behaviour`, `Mesh Filter`, `Render`,  `Transform`, 这些都继承Component

`MonoBehaviour` 继承 `Behaviour`，用户扩展自定义脚本

`自定义脚本`继承`MonoBehaviour`


## 生命周期

大范围的：Awake() =>  **onEnable()** => OnApplicationQuit() => **OnDisable()** => OnDestroy()

不加粗的在生命周期里只执行一次

生命周期fixedUpdate： Unity3D可以设置每隔固定时间，进行一次更新。
注：每一帧的update会在fixedUpdate**之后**，执行如果出现丢帧（一帧的时间超过fixedUpdate固定间隔），就可能导致一帧里执行了多次fixedUpdate方法。

Maximum Particle Timestamp：可以设置一帧最大间隔时间


协程Coroutine：创建协程方法：StartCoroutine(call())

IEnumerator: 不是枚举的接口，在unity里，这是用来实现yield 状态机的。
C# engine会识别方法里的每一个`yield return `关键字，然后等待下一帧执行；

执行顺序
```
update => yield null => yield waitForSeconds => yield WWW => yild starCoroutine
```

## 脚本逻辑更新

Update =>yield 相关的更新 => 动画系统的更新 =>  LateUpdate

Awake, OnEnable是第0帧执行的

Start，首次Update，首次LateUpdate是在第1帧执行的



## 渲染事件callabck以及他们的顺序

``
```
onPreCull
onWillRenderObject
onBecomeVisible
onBecomeInvisible
onPreRender // 渲染场景前
onRenderObject 开始渲染场景
onPostRender // 渲染场景后
onRenderImage // 全部渲染完毕后

```


## 脚本的管理

脚本的执行顺序：启动游戏时，所有脚本会被同时处理（同时执行所有脚本的某一个生命周期，比如Awake方法）

通过编辑器可以设置脚本执行顺序，越小的越先执行

![[Pasted image 20251121080323.png]]

也可以在脚本上加标注
```
[DefaultExecutionOrder(100)]

public class test : MonoBehaviour {
}
```