了解动态加载的原理



实现原理：

首先，我们会将我们的动态模块打包成一个动态chunk。 

比如我的`dynamicModule`被打包成了`src_dynamicModule_js`

```js
const dynamicModule = {
  name: "dynamicModule",
  template: "{{name}}",
  script: `export default {data() {return {name: "lalala"}}}`,
};
export default dynamicModule;

```



```js
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmy_webpack_project"] = self["webpackChunkmy_webpack_project"] || []).push([["src_dynamicModule_js"],{

/***/ "./src/dynamicModule.js":
/*!******************************!*\
  !*** ./src/dynamicModule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst dynamicModule = {\n  name: \"dynamicModule\",\n  template: \"{{name}}\",\n  script: `export default {data() {return {name: \"lalala\"}}}`,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dynamicModule);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/dynamicModule.js?");

/***/ })

}]);
```

eval里面的代码如下

```js
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const dynamicModule = {
  name: "dynamicModule",
  template: "{{name}}",
  script: `export default {data() {return {name: "lalala"}}}`,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dynamicModule);


//# sourceURL=webpack://my-webpack-project/./src/dynamicModule.js?
```





动态import代码会被webpack转化成内部的实现

这个是动态加载的源码 + 转化后的代码

```js
const dynamicModule = () => import("./src/dynamicModule.js");
```



```js
const dynamicModule = () => __webpack_require__.e(/*! import() */ "src_dynamicModule_js").then(__webpack_require__.bind(__webpack_require__, /*! ./dynamicModule */ "./src/dynamicModule.js"));
```

当dynamicModule被执行时，实际上就是执行`__webpack_require__.e`方法。



webpack会等待promise状态变成resolved，然后将结果缓存在`installedChunks`上

```js
// key代表chunkId
// value代表loading的状态: 
	undefined表示没load过
	null代表prefetched或者preloaded
	[resolve, reject, Promise] 一个数组，代表正在loading
	0代表loaded完成
	
var installedChunks = {
	"main": 0
};
```



然后将script 动态append到html标签上；

浏览器下载script标签，然后解析并且执行script里的内容；

将promise状态变为resolved；



`__webpack_require__`对象上有很多属性

```
__webpack_require__.r 用来创建一个exports对象
__webpack_require__.d 调用Object.defineProperty给exports设置属性；
__webpack_require__.l 核心方法，动态加载我们的script

__webpack_require__.e webpack实现的ensure chunk
__webpack_require__.f {
	j: jsonp，实现chunk的loading和存储；
}
```







总结其实就三个步骤：

先对异步加载模块的代码进行分析、转化，生成异步的chunk。

然后加载异步代码，如果异步的chunk没加载过，就先生成script标签去加载；

加载完毕后，解析异步代码，执行回调函数；

