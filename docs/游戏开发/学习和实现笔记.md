

## 带着问题


### 1、主循环在干嘛？
主循环通过requestAnimationFrame来实现的；
每一帧里，做了以下几件事情：

1. 去判断游戏是否还在进行中？如果是的话，那么清空所有的物体，更新云、障碍物、恐龙等物体；
2. 判断物体是否有触碰，如果触碰了，游戏结束了。
3. 更新游戏的分数；
4. 调用下一帧循环

### 2、恐龙，天空，背景，障碍物等物体是怎么移动的？

#### 谁动谁不动？

恐龙不动，需要将背景（天空、障碍物、地面）等一直向后（左边）在动；

#### 地面的移动：

地面sprite宽度为1200，我们分成两个600，随机出现，这样可以制造4种不同的地面效果；

实现的时候，需要绘制3个600，等第一个移动超出屏幕时，将它拼接到最后面；

#### 动画速度：

PixiJS animationSpeed 是每帧更新的频率，1 表示每帧更新一次

原代码里设置的速度是帧率：framesPerSecond = 1000/6，表示一秒更新6帧；

而一般游戏的FPS=60，每秒是60帧。 

因此换算得到， pixijs里的速度：

```ts
 n = 6/60 = 0.1
```



#### 移动速度：

源代码里的速度是：

```ts
const increment = Math.floor(speed * (FPS / 1000) * deltaTime);
```



计算每一帧的时间，乘以速度，得到移动的距离。



### 3、障碍物的随机生成

#### 3.1 翼龙的随机位置（y）

有三个位置，每次重新生成时，随机（0，2）然后根据index设置位置；

#### 3.2 仙人掌的随机数量（1,3）

创建障碍物的时候，先随机生成一个size，然后比较当前游戏的速度。

如果速度满足这个size，则保持size不变；否则size重置为1；

sprite怎么取的？sprite里是按1,2,3这样的顺序排列的，因此需要计算位移

![image-20241201213828941](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2024/12-01/image-20241201213828941.png)

因此代码如下：

```ts
// X position in sprite
let sourceX =
  sourceWidth * this.size * (0.5 * (this.size - 1)) + this.spritePos.x;

// Animation frames
if (this.currentFrame > 0) {
  sourceX += sourceWidth * this.currentFrame;
}
```



#### 3.4、生成障碍物的条件？

a. 随机一个障碍物的类型，然后判断是否满足重复次数的条件；

b. 判断当前是否已有障碍物：

​	如果有，需要判断前面一个障碍物是否可见，新创建的障碍物与最后一个障碍物之间的gap是否够；

​	如果没有障碍物，那么就直接创建障碍物；

gap是否足够？

每一个障碍物都配置了最小速度minSpeed

最小gap minGap

当速度足够时，才会出现这个障碍物；

然后障碍物与障碍物之间的gap会根据这个minGap进行计算；



#### 3.5、怎么控制障碍物之间的gap？

就算最小距离，最大距离，然后随机生成一个中间值；



最小距离：

```tsx
    const minGap = Math.round(
      this.sprite.width * speed +
      this.config.minGap * GAME_CONSTANTS.Obstacle.GAP_COEFFICIENT
    );
```


计算最小的gap : speed * width + minGap * 系数
最大距离：
```
```tsx
 // 速度*障碍物宽度+最小间隙*间隙系数

```
    // 最小间隙*最大间隙系数
    const maxGap = Math.round(
      minGap * GAME_CONSTANTS.Obstacle.MAX_GAP_COEFFICIENT
    );
```

最后取中间随机数



### 4、障碍物碰撞检测
定义两个rectangle，然后去计算两个rectangle是否有交差碰撞；

```ts
function checkForCollision(obstacle, tRex, opt_canvasCtx) {
  var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;

  // Adjustments are made to the bounding box as there is a 1 pixel white
  // border around the t-rex and obstacles.
  var tRexBox = new CollisionBox(
      tRex.xPos + 1,
      tRex.yPos + 1,
      tRex.config.WIDTH - 2,
      tRex.config.HEIGHT - 2);

  var obstacleBox = new CollisionBox(
      obstacle.xPos + 1,
      obstacle.yPos + 1,
      obstacle.typeConfig.width * obstacle.size - 2,
      obstacle.typeConfig.height - 2);

  // Debug outer box
  if (opt_canvasCtx) {
      drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
  }

  // Simple outer bounds check.
  boxCompare(tRexBox, obstacleBox)   
}
```



碰撞箱的设计：，并不是一个矩形，而是多个小的矩形的组合；

比如仙人掌：它有：

左侧分支 new CollisionBox(0, 7, 5, 27)

中间主干 new CollisionBox(4, 0, 6, 34)

右侧分支 new CollisionBox(10, 4, 7, 14)

![image-20241206214526730](https://ipic-coda.oss-cn-beijing.aliyuncs.com/2024/12-06/image-20241206214526730.png)

大概形状就是：

```
	  +----+
    |    |---+
+---+        |
|            |
|        +---+    
+--------+
```



仙人掌的个数不同，碰撞形状也有点不同，大概如下：

```tsx
// Make collision box adjustments,
        // Central box is adjusted to the size as one box.
        //      ____        ______        ________
        //    _|   |-|    _|     |-|    _|       |-|
        //   | |<->| |   | |<--->| |   | |<----->| |
        //   | | 1 | |   | |  2  | |   | |   3   | |
        //   |_|___|_|   |_|_____|_|   |_|_______|_|
        //

        if (this.size > 1) {
          this.collisionBoxes[1].width =
            this.width -
            this.collisionBoxes[0].width -
            this.collisionBoxes[2].width;
          this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
        }
```

### 7、怎么用键盘控制上、下

全局监听键盘的up，down事件

up的处理：先给一个初始的跳跃速度，然后按加速度0.6递减，变为0时，开始下降；

down的事件：如果在jumping，那么进行速降；然后直接替换sprite；

### 4、积分系统？怎么算距离的？速度怎么叠加的？

随着时间的变化，游戏速度越来越快，路程也越来越多，这块怎么统计的？

就是在每一帧循环里，累计路程，增加speed;





## 细节问题

#### 定位点的设置

```ts
  // 对于x轴：0 是左边，1 是右边，0.5 是中间
  // 对于y轴：0 是顶部，1 是底部，0.5 是中间
  ground.anchor.set(0);
```



#### 地面的移动

使用平铺的sprite，然后让它一直向左

```ts
  const ground = new TilingSprite({
    texture: groundTexture,
    width: app.screen.width,
    height: spriteDefinitions.GROUND.height,
  });
  // 对于x轴：0 是左边，1 是右边，0.5 是中间
  // 对于y轴：0 是顶部，1 是底部，0.5 是中间
  ground.anchor.set(0, 1);
  ground.x = 0;
  ground.y = GAME_CONSTANTS.GAME_HEIGHT;
  app.stage.addChild(ground);

app.ticker.add(() => {
    // 让地面一直向左移动
    ground.tilePosition.x -= 1; // 负值表示向左滚动，正值表示向右滚动
  });
```



#### 人物的加载





### 面向对象的思路

定义不同的class来表示不同类型的物体，

#### 如何更新？

每一个class类里提供update方法，在update的实现里去重新绘制sprite。

最后在app.state.ticker里加入这个update方法作为回调函数；
